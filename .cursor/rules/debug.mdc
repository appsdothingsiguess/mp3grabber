---
description: 
globs: 
alwaysApply: true
---
# .cursorrules - JoeySpace/hub-of-sunshine-apps

# ==================================
# DEVELOPMENT WORKFLOW & PHASES
# ==================================
# This is the standard operating procedure for all development tasks.
# Follow these phases sequentially.

# Phase 1: Search & Understand
# - Before starting any new task, perform a comprehensive search of the entire codebase.
# - Goal: Understand existing patterns, dependencies, and potential areas of impact.
# - Example: "Search for all instances of `useAuth` to see how it's used before creating a new protected component."

# Phase 2: Create a Detailed Plan
# - For any new feature or significant refactor, first generate a detailed, step-by-step implementation plan.
# - The plan should be in a markdown format and outline file changes, new components/functions, and necessary database migrations.
# - Example: "Create a plan to add a commenting feature to the `SprintApp`. Include the new `comments` table schema, API endpoints, and frontend components."

# Phase 3: Implement the Plan
# - Execute the plan one step at a time. Focus on a single file or logical change before moving to the next.
# - If a step becomes too complex or introduces too many changes, stop immediately (Phase 3b).
# - Example: "Implement step 1 of the plan: Create the `ManageComments.tsx` component with placeholder UI."
# 

# Phase 3b: Complexity Management
# - If an implementation step proves too complex, halt and request a more granular, broken-down plan for that specific part.
# - Do not proceed with overly complex, multi-faceted changes at once.
# - Example: "Stop. Step 3 is too complex. Break down the state management for the comments feature into smaller, more manageable parts."

# Phase 4: Analyze Changes & Identify Bugs
# - After implementation is complete, generate a summary of all changes.
# - Analyze the implemented code for potential bugs, side-effects, or regressions.
# - YOU MUST ALWAYS run the command: npm test and if any errors occur read them and fix all relevent erros to the code you produced. 
# - Suggest test cases (both manual and automated) to verify the new functionality and ensure existing features are not broken.
# - Example: "Analyze the changes made to the `useWallpapers` hook. Are there any race conditions? Suggest test cases for uploading, deleting, and setting an active wallpaper."

# Phase 5: Generate SQL Commands
# - If the plan required database changes, provide the necessary SQL migration scripts.
# - Place these scripts in the `supabase/migrations` directory.
# - The filename should follow the convention: `YYYYMMDDHHMMSS_description_of_change.sql`.
# - Example: "Generate the SQL script to add a `is_featured` column to the `sprint_wallpapers` table."

# ==================================
# GENERAL CODING STANDARDS
# ==================================
- Use TypeScript for all new components and logic. Enforce strict mode.
- Favor named exports over default exports for components and hooks.
- Keep file and directory names in kebab-case (e.g., `my-component.tsx`).
- All new components should be placed in the `src/components` directory, with UI components in `src/components/ui`.

# ==================================
# REACT & STATE MANAGEMENT
# ==================================
- Use functional components with hooks.
- All new hooks should be placed in the `src/hooks` directory.
- For local component state, use `useState` and `useReducer`.
- For server state, caching, and mutations, exclusively use TanStack Query.
- All TanStack Query hooks should be located in `src/hooks/useQueryHooks.ts` (for queries) and `src/hooks/useMutationHooks.ts` (for mutations).
- All query keys must be managed in and imported from `src/hooks/queryKeys.ts`.

# ==================================
# STYLING & UI
# ==================================
- Use Tailwind CSS for all styling. Do not use inline styles or CSS-in-JS.
- Strictly adhere to the `BUTTON_STYLE_GUIDE.md` for all button variants (`primary`, `secondary`, `destructive`, `ghost`), sizes, and border-radius conventions.
- New UI components should be created using `shadcn/ui` as a foundation.

# ==================================
# SUPABASE & DATABASE
# ==================================
- All Supabase client interactions must be through the singleton instance exported from `src/integrations/supabase/client.ts`.
- When creating new database migrations, ensure that Row Level Security (RLS) is enabled by default for all new tables.
- All policies must enforce user isolation (e.g., `auth.uid() = user_id`) and provide admin overrides where necessary (`is_admin(auth.uid())`).
- For performance, all policies must use `(select auth.uid())` instead of `auth.uid()`.
- Consolidate multiple permissive policies for the same role and action into a single, comprehensive policy to optimize query performance.

# ==================================
# ERROR HANDLING & LOGGING
# ==================================
- All asynchronous functions and operations that can fail must be wrapped in `try...catch` blocks.
- Use the `useToast` hook for all user-facing success or error messages.
- Use the `useLogger` hook for console logging. `logError` should be used for all caught errors. `logDebug` should be used for development-specific diagnostic information.
- All authentication-related errors must be sanitized using the `sanitizeAuthError` utility before being displayed or logged.

# ==================================
# API & EDGE FUNCTIONS
# ==================================
- New Supabase Edge Functions must be placed in the `supabase/functions` directory.
- All Edge Functions must handle CORS preflight (`OPTIONS`) requests.
- All Edge Functions must include authentication checks to verify the user's JWT and ensure they are authorized to perform the requested action, checking for admin status if required.
